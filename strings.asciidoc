= Dart Cookbook
:author: Shailen Tuli
:encoding: UTF-8

== Strings

=== Concatenating strings

==== Problem

You want to concatenate strings in Dart.

==== Solution

Use the `+` operator, or use adjacent string literals.

==== Discussion

Using the `+` operator is an easy way to concatenate strings:

--------------------------------------------------------------------------------
'Dart ' + 'is ' + 'fun!'; // 'Dart is fun!'
--------------------------------------------------------------------------------

You can use the `+` to concatenate single-line and multi-line strings:

--------------------------------------------------------------------------------
'Dewey ' + 'Cheatem' +
''' and
Howe'''; // 'Dewey Cheatem and\n Howe'
--------------------------------------------------------------------------------

You can also use adjacent string literals:

--------------------------------------------------------------------------------
'Dart '  'is '  'fun!'; // 'Dart is fun!'
--------------------------------------------------------------------------------

Adjacent literals work over multiple lines:

--------------------------------------------------------------------------------
'Dart '
'is '
'fun!'; // 'Dart is fun!'
--------------------------------------------------------------------------------

If the string fragments you wish to concatenate are already in a list, use
`join()`:

--------------------------------------------------------------------------------
['The', 'Big', 'Lebowski'].join(' '); // 'The Big Lebowski'
--------------------------------------------------------------------------------

You can also use string interpolation, which is often more efficient than
concatenation. See
xref:string-interpolation[Interpolating expressions inside strings]

If you want to incrementally build a longish string from its parts, a
StringBuffer works more efficiently than string concatenation. See
xref:string-buffer[Incrementally building a string efficiently using a
StringBuffer].

<<string-interpolation>>
=== Interpolating expressions inside strings

==== Problem

You want interpolate the value of an identifier, a function or method call, or
other arbitrary Dart code inside a Dart string.

==== Solution

You can put the value of any Dart  expression inside a string by using
`${expression}` syntax:

--------------------------------------------------------------------------------
var favFood = 'sushi';
'I love ${favFood.toUpperCase()}'; // 'I love SUSHI'
--------------------------------------------------------------------------------

You can skip the `{}` if the expression is an identifier:

--------------------------------------------------------------------------------
'I love $favFood'; // 'I love sushi'
--------------------------------------------------------------------------------

==== Discussion

The interpolated string, `'string ${expression}'` is equivalent to the
concatenation of the strings `string` and `expression.toString()`.

Consider this string interpolation example:

--------------------------------------------------------------------------------
var four = 4;
'The $four seasons'; // 'The 4 seasons'
--------------------------------------------------------------------------------

The code above is functionally equivalent to the following:

--------------------------------------------------------------------------------
'The ' + 4.toString() + ' seasons';
--------------------------------------------------------------------------------

Consider implementing a `toString()` method for classes that you define. Here's
what happens if you don't:

--------------------------------------------------------------------------------
class Point {
  int x, y;
  Point(this.x, this.y);
}

void main() {
  var point = new Point(3, 4);
  print('Point: $point');
}
--------------------------------------------------------------------------------

Running the program above produces the following output:

--------------------------------------------------------------------------------
"Point: Instance of 'Point'"
--------------------------------------------------------------------------------

This is probably not what you wanted. Here is the same example but with an
explicit `toString()` added to the Point class:

--------------------------------------------------------------------------------
class Point {
  ...

  String toString() => 'x: $x, y: $y';
}

void main() {
  print('Point: $point');
}
--------------------------------------------------------------------------------

The interpolation of the Point object in a string now produces more meaningful
output:

--------------------------------------------------------------------------------
'Point: x: 3, y: 4'
--------------------------------------------------------------------------------

<<special-characters>>
=== Handling special characters within strings

==== Problem

You want to put newlines, dollar signs, or other special characters in strings.

==== Solution

Prefix special characters with a `\`. This ensures that the characters are
interpreted literally.

==== Discussion

Here is an example of a newline character, `\n`, embedded in a two-word string:

--------------------------------------------------------------------------------
print('Wile\nCoyote');
--------------------------------------------------------------------------------

When the code above  executes, the `\n` is interpreted as a special character,
and the words print on separate lines:

--------------------------------------------------------------------------------
Wile
Coyote
--------------------------------------------------------------------------------

Dart designates a few characters as special, and these can be escaped:

* \n for newline, equivalent to \x0A.
* \r for carriage return, equivalent to \x0D.
* \f for form feed, equivalent to \x0C.
* \b for backspace, equivalent to \x08.
* \t for tab, equivalent to \x09.
* \v for vertical tab, equivalent to \x0B.

If you prefer, you can use `\x` or `\u` notation with Hex digits to indicate
special characters:

The `\x` character must be followed by two Hex digits:

--------------------------------------------------------------------------------
'Wile\x0ACoyote';   // 'Wile\nCoyote'
--------------------------------------------------------------------------------

The `\u` character must be followed by four Hex digits:

--------------------------------------------------------------------------------
'Wile\u000ACoyote'; // 'Wile\nCoyote'
--------------------------------------------------------------------------------

You can also use `\u{}` notation, with a Hex value placed within the `{}`:

--------------------------------------------------------------------------------
'Wile\u{000A}Coyote'; // 'Wile\nCoyote'
--------------------------------------------------------------------------------

The `$` character is used in string interpolation (see
xref:string-interpolation[Interpolating expressions inside strings]), and you
can escape it using '\':

--------------------------------------------------------------------------------
var superGenius = 'Wile Coyote';
'$superGenius and Road Runner';  // 'Wile Coyote and Road Runner'
'\$superGenius and Road Runner'; // '$superGenius and Road Runner'
--------------------------------------------------------------------------------

If you escape a non-special character, the `\` is ignored:

--------------------------------------------------------------------------------
'Wile \E Coyote'; // 'Wile E Coyote'
--------------------------------------------------------------------------------

====== Raw strings and special characters

Prefixing the starting quote of a string with `r` converts a regular string into
a raw string. Special characters and the `$` symbol are stripped of any special
meaning in raw strings:

--------------------------------------------------------------------------------
r'Wile \n Coyote';               // 'Wile \n Coyote'
'\$superGenius and Road Runner'; // '$superGenius and Road Runner'
--------------------------------------------------------------------------------

Raw strings are commonly used when working with regular expressions. See
xref:using-regexp[Finding matches using a regular expression].


<<string-buffer>>
=== Incrementally building a string using a StringBuffer

==== Problem

You want to accumulate and combine string fragments in an efficient manner.

==== Solution

Use a StringBuffer. Write repeatedly to a buffer using the various write*()
methods provided in the StringBuffer class, and then concatenate the fragments
into a single string using `toString()`.

==== Discussion

A StringBuffer collects string fragments but avoids concatenating those
fragments into a new string until instructed to do so. Using a StringBuffer is
the recommended way of accumulating string fragments and is more efficient than
using string concatenation.

The two most commonly used StringBuffer methods are `write()` and `toString()`.
Use `write()` to add fragments to the buffer, and use `toString()` to return
the contents of the buffer as a concatenated string.

The example below uses a StringBuffer to assemble a list of URIs from URI
components stored in a list:

--------------------------------------------------------------------------------
var data = [{'scheme': 'https', 'domain': 'news.ycombinator.com'},
            {'domain': 'www.google.com'},
            {'domain': 'reddit.com', 'path': 'search', 'params': 'q=dart'}
           ];

String assembleUrisUsingStringBuffer(entries) {
  StringBuffer sb = new StringBuffer();
  for (final item in entries) {
    sb.write(item['scheme'] != null ? item['scheme']  : 'http');
    sb.write("://");
    sb.write(item['domain']);
    sb.write('/');
    sb.write(item['path'] != null ? item['path']  : '');
    if (item['params'] != null) {
      sb.write('?');
      sb.write(item['params']);
    }
    sb.write('\n');
  }
  return sb.toString();
}
--------------------------------------------------------------------------------

Running the program prints the following:

--------------------------------------------------------------------------------
https://news.ycombinator.com/
http://www.google.com/
http://reddit.com/search?q=dart
--------------------------------------------------------------------------------

Here is the same example rewritten to to use string concatenation.  This
generates the same list of URIs as the code above,  but incurs the performance
cost of joining strings multiple times:

--------------------------------------------------------------------------------
String assembleUrisUsingConcatenation(data) {
  var uris = '';
  for (final item in data) {
    uris += item['scheme'] != null ? item['scheme']  : 'http';
    uris += "://";
    uris += item['domain'];
    uris += '/';
    uris += item['path'] != null ? item['path']  : '';
    if (item['params'] != null) {
      uris += '?';
      uris += item['params'];
    }
    uris += '\n';
  }
  return uris;
}
--------------------------------------------------------------------------------


===== Other StringBuffer methods

In addition to `write()`, the StringBuffer class provides methods to
write a list of strings (`writeAll()`), write a numerical character code
(`writeCharCode()`), write with an added newline (`writeln()`), and
more. The example below shows how to use these methods:

--------------------------------------------------------------------------------
var sb = new StringBuffer();
sb.writeln('The Beatles:');
sb.writeAll(['John, ', 'Paul, ', 'George, and Ringo']);
sb.writeCharCode(33); // charCode for '!'.
var beatles = sb.toString(); // 'The Beatles:\nJohn, Paul, George, and Ringo!'
--------------------------------------------------------------------------------


=== Determining whether a string is empty

==== Problem

You want to know whether a string is empty. You tried `if (string) { ... }`, but
that did not work.

==== Solution

Use the `isEmpty` or `isNotEmpty` properties of a String to test whether it is
empty:

--------------------------------------------------------------------------------
var emptyString = '';
emptyString.isEmpty;    // true
emptyString.isNotEmpty; // false
--------------------------------------------------------------------------------

You can also just use `==` and compare a string to an empty string:

--------------------------------------------------------------------------------
if (string == '') {...} // True if string is empty.
--------------------------------------------------------------------------------

==== Discussion

In Dart, a string with a space is not empty:

--------------------------------------------------------------------------------
var space = ' ';
space.isEmpty; // false
--------------------------------------------------------------------------------

Don't use `if (string)` to test the emptiness of a string. In Dart, all objects
except the boolean `true` evaluate to false, so `if (string)` is always false.
You see a warning in the editor if you use an 'if' statement with a non-boolean
in checked mode.


=== Removing leading and trailing whitespace

==== Problem

You want to remove spaces, tabs, and other whitespace from the beginning and
end of strings.

==== Solution

Use `string.trim()`:

--------------------------------------------------------------------------------
var space = '\n\r\f\t\v';       // A variety of space characters.
var string = '$space X $space';
string.trim();                  // 'X'
--------------------------------------------------------------------------------

The String class has no methods to remove only leading or only trailing
whitespace, but you can always use a RegExp.

Here is how you can remove only leading whitespace:

--------------------------------------------------------------------------------
string.replaceFirst(new RegExp(r'^\s+'), ''); // 'X \n\r\f\t\v'
--------------------------------------------------------------------------------

And here is how you can remove only trailing whitespace:

--------------------------------------------------------------------------------
string.replaceFirst(new RegExp(r'\s+$'), ''); // '\n\r\f\t\v X'
--------------------------------------------------------------------------------


=== Changing string case

==== Problem

You want to change the case of strings.

==== Solution

Use String's `toUpperCase()` and `toLowerCase()` methods:

--------------------------------------------------------------------------------
var sitcom = 'I love Lucy';
sitcom.toUpperCase();                                // 'I LOVE LUCY!'
sitcom.toLowerCase();                                // 'i love lucy!'

// Zeus in modern Greek.
var zeus = '\u0394\u03af\u03b1\u03c2';               // 'ŒîŒØŒ±œÇ'
zeus.toUpperCase();                                  // 'ŒîŒäŒëŒ£'

var resume = '\u0052\u00e9\u0073\u0075\u006d\u00e9'; // 'R√©sum√©'
resume.toLowerCase();                                // 'r√©sum√©'
--------------------------------------------------------------------------------

The `toUpperCase()` and `toLowerCase()` methods don't affect the characters of
scripts such as Devanagri that don't have distinct letter cases.

--------------------------------------------------------------------------------
var chickenKebab = '\u091a\u093f\u0915\u0928 \u0915\u092c\u093e\u092c';
// '‡§ö‡§ø‡§ï‡§® ‡§ï‡§¨‡§æ‡§¨'

chickenKebab.toLowerCase();  // '‡§ö‡§ø‡§ï‡§® ‡§ï‡§¨‡§æ‡§¨'
chickenKebab.toUpperCase();  // '‡§ö‡§ø‡§ï‡§® ‡§ï‡§¨‡§æ‡§¨'
--------------------------------------------------------------------------------

If a character's case does not change when using `toUpperCase()` and
`toLowerCase()`, it is most likely because the character only has one form.

<<extended-characters>>
=== Handling extended characters that are composed of multiple code units

==== Problem

You want to use emoticons and other special symbols that don't fit into 16
bits. How can you create such strings and use them correctly in your code?

==== Solution

You can create an extended character using `'\u{}'` syntax. Here is an example:

--------------------------------------------------------------------------------
var clef = '\u{1D11E}'; // ùÑû
--------------------------------------------------------------------------------

Strings that contain extended characters can be liberally used in your code.
However, methods and properties that expose an extended character's individual
code units should be carefully handled or avoided. These are discussed below.

==== Discussion

Most UTF-16 strings are stored as two-byte (16-bit) code sequences.  Since two
bytes can only contain the 65,536 characters in the 0x0 to 0xFFFF range, a pair
of strings is used to store values in the 0x10000 to 0x10FFFF range. These
strings only have semantic meaning as a pair. Individually, they are invalid
UTF-16 strings. The term 'surrogate pair' is often used to describe these
strings.

The treble clef glyph `'\u{1D11E}'`, for example,  is composed of the `'\uD834'`
and `'\uDD1E'` surrogate pair.

You can get an extended string's surrogate pair through its `codeUnits`
property:

-------------------------------------------------------------------------------
clef.codeUnits.map((codeUnit) => codeUnit.toRadixString(16));
// ['\uD834', '\uDD1E']
-------------------------------------------------------------------------------

Accessing a surrogate pair member leads to errors, and you should avoid
properties and methods that expose it.

For example, it is common to  use `split()` with an empty string as the
delimiting pattern for breaking up a string into individual characters.  Avoid
this usage when working with extended characters. Since `split()` operates
at UTF-16 code unit boundaries and not at rune boundaries, it can yield one half
of a surrogate pair, which is an invalid string. Calling `clef.split('')`, for
example, returns a list containing '\uD834' and '\uDD1E', and attempting to
print either string results in an error:

-------------------------------------------------------------------------------
print('\uD834');  // Error: '\uD834' is not a valid string.
print('\uDD1E');  // Error: '\uDD1E' is not a valid string either.
-------------------------------------------------------------------------------

For working with individual characters in a string, it is safer to map the
string runes instead:

--------------------------------------------------------------------------------
void main() {
  var clef = '\u{1D11E}';
  var characters = '$clef is a G clef'.runes.map((rune) {
    return new String.fromCharCode(rune);
  }).toList();
  print(characters);
}
--------------------------------------------------------------------------------

The code above prints the following:

--------------------------------------------------------------------------------
['ùÑû', ' ' , 'i', 's', ' ', 'a', ' ' , 'G' , ' ', 'c', 'l', 'e', 'f']
--------------------------------------------------------------------------------

The `[]` operator also works at code unit boundaries, and you should avoid
directly subscripting an extended string:

-------------------------------------------------------------------------------
print(clef[0]); // Invalid string. Dart Editor prints '?'
-------------------------------------------------------------------------------

Instead, subscript a string's `runes` list:

--------------------------------------------------------------------------------
clef.runes.toList()[0].toRadixString(16);  // '\u{1D11E}'
--------------------------------------------------------------------------------

See the API docs for the String class for more details on how to correctly
work with extended strings. As a general principle, avoid dealing with code
units and members that expose them. Instead, work on rune boundaries when
possible.

See the
xref:characters-and-numerical-codes[Converting between characters and numerical codes])
recipe for a discussion on how to convert between numerical codes and strings
with extended characters.

See the
xref:calculating-length[Calculating the length of a string] recipe for a
discussion on calculating the length of a string that contains extended
characters.

<<characters-and-numerical-codes>>
=== Converting between characters and numerical codes

==== Problem

You want to convert string characters into numerical codes and vice versa.
You want to do this because sometimes you need to compare characters in a string
to numerical values coming from another source. Or, maybe you want to split a
string and then operate on each character.

==== Solution

To convert a string to numerical codes, use the `runes` or the `codeUnits`
properties. To convert numerical codes to strings, use the
`String.fromCharCodes()` or `String.fromCharCode()` factory constructors.

==== Discussion

The `runes` property returns a string's code points:

--------------------------------------------------------------------------------
'Dart'.runes.toList();     // [68, 97, 114, 116]

var smileyFace = '\u263A'; // ‚ò∫
smileyFace.runes.toList(); // [9786], (equivalent to ['\u263A']).
--------------------------------------------------------------------------------

The `codeUnits` property returns string's UTF-16 code units:

--------------------------------------------------------------------------------
'Dart'.codeUnits.toList();     // [68, 97, 114, 116]
smileyFace.codeUnits.toList(); // [9786]
--------------------------------------------------------------------------------

For most strings, the `runes` and `codeUnits` properties return the same
values. For extended characters composed of multiple code units,
`runes` combines and returns a single integer, while `codeUnits` returns the
individual code units:

--------------------------------------------------------------------------------
var clef = '\u{1D11E}';  // ùÑû
clef.runes.toList();     // [119070], (equivalent to ['\u{1D11E}']).
clef.codeUnits.toList(); // [55348, 56606]
--------------------------------------------------------------------------------

To get the code unit at a particular index, use `codeUnitAt()`:

--------------------------------------------------------------------------------
'Dart'.codeUnitAt(0);     // 68
smileyFace.codeUnitAt(0); // 9786 (the decimal value of '\u263A')
clef.codeUnitAt(0);       // 55348 (WARNING: NOT A LEGAL STRING)
--------------------------------------------------------------------------------

Using `codeUnitAt()` with an extended string like `clef` returns the code unit
for one half of a surrogate pair. This does not represent a legal string.

==== Converting numerical codes to strings

You can generate a new string from numerical codes using the factory
`String.fromCharCodes()` constructor, passing it a list of character codes as
an argument. You can pass either runes or code units and
`String.fromCharCodes(charCodes)` can tell the difference and do the right
thing automatically:

--------------------------------------------------------------------------------
new String.fromCharCodes([68, 97, 114, 116]);                   // 'Dart'
new String.fromCharCodes([73, 32, 9825, 32, 76, 117, 99, 121]); // 'I ‚ô° Lucy'

// Passing code units representing a surrogate pair.
new String.fromCharCodes([55348, 56606]));                      // ùÑû

// Passing runes.
new String.fromCharCodes([119070]);                             // ùÑû
--------------------------------------------------------------------------------

You can use the `String.fromCharCode()` factory to convert a single rune or code
unit to a string:

--------------------------------------------------------------------------------
new String.fromCharCode(68);     // 'D'
new String.fromCharCode(9786);   // ‚ò∫
new String.fromCharCode(119070); // ùÑû
--------------------------------------------------------------------------------

Creating a string with only one half of a surrogate pair is permitted but not
recommended.

For a general discussion on working with extended characters, see
xref:extended-characters[Handling extended characters that are composed of multiple code units].

<<calculating-length>>
=== Calculating the length of a string

==== Problem

You want to get the length of a string but are not sure how to calculate the
length correctly when working with variable length Unicode characters.

==== Solution

Use `length` to get a string's code-unit length and `runes.length` to get its
code-point length. You want to use the latter for strings containing extended
characters composed of multiple code units.

==== Discussion

In general, you do not want to assume that a string contains only characters
that are made up of a single code unit. For this reason, using
`string.runes.length` is a safer bet and returns the number of characters in
_any_ Dart string:

--------------------------------------------------------------------------------
'I love music'.runes.length;   // 12
var clef = '\u{1D11E}';        // ùÑû
clef.runes.length;             // 1
--------------------------------------------------------------------------------

You can also directly use a string's `length` property (minus `runes`). This
returns the string's code unit length. Using `string.length` produces the same
length as `string.runes.length` for most unicode characters. For extended
characters, the code unit length is one more than the rune length:

--------------------------------------------------------------------------------
'I love music'.length;         // 12
clef.length;                   // 2
clef.runes.length;             // 1
--------------------------------------------------------------------------------

Unless you specifically need the code unit length of a string, prefer working
with the rune length.

For a general discussion on working with extended characters, see
xref:extended-characters[Handling extended characters that are composed of multiple code units].

===== Working with combined characters

It is tempting to brush aside the complexity involved in dealing with runes and
code units and base the length of the string on the number of characters it
appears to have. Anyone can tell that 'Dart' has four characters, and 'Ameli√©'
has six, right? Almost. The length of 'Dart' is indeed four, but the length of
'Ameli√©' depends on how that string was constructed:

--------------------------------------------------------------------------------
var name = 'Ameli\u00E9';               // One way of writing 'Ameli√©'.
name.length;                            // 6
var anotherName = 'Ameli\u0065\u0301';  // Another way of writing 'Ameli√©'.
anotherName.length;                     // 7
--------------------------------------------------------------------------------

Both `name` and `anotherName` return strings that look the same, but where
the '√©' is constructed using a different number of runes. In `name`, the '√©' is
constructed using a precomposed character ('\u00E9').  This character can be
decomposed into an equivalent string comprising of a base letter ('\u0065') and
an acute accent ('\u0301'). The `anotherName` variable is defined using the
decomposed units. This makes it impossible to know the length of these strings
by just looking at them.


=== Splitting a string into substrings

==== Problem

You want to split a string into substrings using a delimiter or a pattern.

==== Solution

Use the `split()` method with a string or a RegExp as an argument.

==== Discussion

Here is an example of a string that is split using a space character as a
delimiter:

--------------------------------------------------------------------------------
var smileyFace = '\u263A';
var happy = 'I am $smileyFace';
var space = ' ';
happy.split(space); // ['I', 'am', '‚ò∫']
--------------------------------------------------------------------------------

Here is an example where the delimiter provided to `split()` is  a RegExp:

--------------------------------------------------------------------------------
var nums = '2/7 3 4/5 3~/5';
var numsRegExp = new RegExp(r'(\s|/|~/)');
nums.split(numsRegExp); // ['2', '7', '3', '4', '5', '3', '5']
--------------------------------------------------------------------------------

In the code above, the string `nums` contains various numbers, some of which
are expressed as fractions or as int-divisions. A RegExp splits the string to
extract just the numbers.

You can perform operations on the matched and unmatched portions of a string
when using `split()` with a RegExp:

--------------------------------------------------------------------------------
var phrase = 'Eats SHOOTS leaves';

var newPhrase = phrase.splitMapJoin((new RegExp(r'SHOOTS')),
  onMatch:    (m) => '*${m.group(0).toLowerCase()}*',
  onNonMatch: (n) => n.toUpperCase());

print(newPhrase); // 'EATS *shoots* LEAVES'
--------------------------------------------------------------------------------

The RegExp matches the middle word ('SHOOTS'). A pair of callbacks are
registered to transform the matched and unmatched substrings before the
substrings are joined together again.

Finally, it is a common pattern to split a string into its individual
characters by using `split()` with an empty string as a delimiter.  Here is an
example:

--------------------------------------------------------------------------------
'Dart'.split('');  // ['D', 'a', 'r', 't']
--------------------------------------------------------------------------------

Since, using `split()` with an empty string pattern ('') splits at UTF-16 code
unit boundaries and not at rune boundaries, this usage can create problems
when working with strings with extended characters that are comprised of
multiple code units. For more details, see
xref:extended-characters[Handling extended characters that are composed of multiple code units].

=== Determining whether a string contains another string

==== Problem

You want to find out whether a string contains another string.

==== Solution

Use the `contains()` method, passing it a pattern as a first argument and
optionally a start index as a second argument. You can also use the
`startsWith()`, `endsWith()`, or `indexOf()` String methods, as well as the
RegExp `hasMatch()` method.

==== Discussion

Here is a simple example of the use of `contains()` to test whether a string
contains another string:

--------------------------------------------------------------------------------
var fact = 'Dart strings are immutable';
fact.contains('immutable');  // true
--------------------------------------------------------------------------------

You can use a second argument to specify where in the string to start looking:

--------------------------------------------------------------------------------
fact.contains('Dart', 2); // false
--------------------------------------------------------------------------------

The pattern passed to `contains()` can be a String or a RegExp. Here is an
example of `contains()` that uses a RegExp:

--------------------------------------------------------------------------------
var library = 'dart:core';
library.contains(new RegExp(r'\w{4}:')); // true
--------------------------------------------------------------------------------


The String class provides a couple of shortcuts for testing whether a string
contains another string at the start or the end:

--------------------------------------------------------------------------------
fact.startsWith('Dart'); // true
fact.endsWith('e');      // true
--------------------------------------------------------------------------------

You can also use `string.indexOf()`, which returns -1 if the substring is not
found within a string, and otherwise returns the matching index:

--------------------------------------------------------------------------------
string.indexOf('art') != -1; // true ('art' is found in 'Dart')
--------------------------------------------------------------------------------

You can also use a RegExp and `hasMatch()`, which returns `true` if the
matching pattern is contained in a string:

--------------------------------------------------------------------------------
new RegExp(r'ar[et]').hasMatch(fact); // true
--------------------------------------------------------------------------------

In the example above, `hasMatch()` returns `true` as the strings, 'are' and
'art' are both contained in `fact`.

<<using-regexp>>
=== Finding matches using a regular expression

==== Problem

You want to use a regular expression to match a pattern in a string, and you
want to be able to get the matched value.

==== Solution

Construct a regular expression using the RegExp class, and find matches using
the `allMatches()`, `firstMatch()`, `hasMatch()`, `matchAsPrefix()`, and
`stringMatch()` methods.

==== Discussion

Construct a regular expression using the RegExp factory constructor:

--------------------------------------------------------------------------------
var regExp = new RegExp(r'(\+|-)?\d[a-z]');
--------------------------------------------------------------------------------

The regular expression constructed above matches any string that optionally
begins with a '+' or a '-', and is then followed by exactly one digit and one
lowercase letter.  Possible matches include '3x', '-4t', '+2y', etc.

The regular expression is constructed using a raw string (a string prefixed
with an 'r'). It is common to use raw strings when constructing RegExp objects.
Characters in a raw string are interpreted literally, with no string
interpolation or escaping of characters (See
xref:special-characters[Handling special characters within strings]).

Using a raw string usually simplifies a regular expression. Here is what the
code above would look like using a non-raw string:

--------------------------------------------------------------------------------
var regExp = new RegExp('(\\+|-)?\\d[a-z]');
--------------------------------------------------------------------------------

Here is a quick explanation for the need for the all the '\' characters:

* The '\' immediately preceeding the '+' is needed because the '+' has special
meaning in regular expressions, and we want to match a literal '+'.
*The '\' preceeding the '\+' is needed because we want a literal '\' before the
'+'.
*The '\' before the 'd' is needed to make the regular expression match a digit
('\d')
*The '\' preceeding the '\d' is needed because we want a literal '\' before the
'd'.

Using a raw string obviates the need to esacpe the '\' in '\+' and '\d'.

Here is an example using the regular expression we defined:

--------------------------------------------------------------------------------
var str = "+3y";
regExp = new RegExp(r'(\+|-)?\d[a-z]');
regExp.stringMatch(str)); // '+3y'
--------------------------------------------------------------------------------

The RegExp class provides several methods to get any matches found for a
regular expression in a string.

To get all matches of a regular expression, use `allMAtches()`:

--------------------------------------------------------------------------------
var neverEatingThat = 'Not with a fox, not in a box';
var regExp = new RegExp(r'[fb]ox');
List matches = regExp.allMatches(neverEatingThat);
matches.map((match) => match.group(0)).toList(); // ['fox', 'box']
matches.length;                                  // 2
--------------------------------------------------------------------------------

To find the first match, use `firstMatch()`:

--------------------------------------------------------------------------------
regExp.firstMatch(neverEatingThat).group(0); // 'fox'
--------------------------------------------------------------------------------

Use `matchAsPrefix()` to match at the start of a string, or another specified
starting position:

--------------------------------------------------------------------------------
var str = "Dart is fun";
var regExp = new RegExp(r'art\s');
regExp.matchAsPrefix(str);             // null
regExp.matchAsPrefix(str, 1).group(0); // 'art'
--------------------------------------------------------------------------------

In the example above, 'art' followed by '\s' does not match the start of
`str`, but it does match `str` starting from the second character.

To directly get the matched string, use `stringMatch()`:

--------------------------------------------------------------------------------
regExp.stringMatch(neverEatingThat);         // 'fox'
regExp.stringMatch('I like bagels and lox'); // null
--------------------------------------------------------------------------------


=== Substituting strings using regular expressions

==== Problem

You want to match substrings within a string and make substitutions based on
the matches.

==== Solution

Construct a regular expression using the RegExp class and replace the matches
strings using the replace*() methods provided in the String class.

==== Discussion

To replace all matched strings with another string, use `replaceAll()`:

--------------------------------------------------------------------------------
'resume'.replaceAll(new RegExp(r'e'), '\u00E9'); // 'r√©sum√©'
--------------------------------------------------------------------------------

In the example above, `replaceAll()` replaces all occurences of 'e' with '√©'.

If you want to replace just the first match, use `replaceFirst()`:

--------------------------------------------------------------------------------
'0.0001'.replaceFirst(new RegExp(r'0+'), ''); // '.0001'
-------------------------------------------------------------------------------

The regular expression defined above matches one or more occurences of '0'.
Using `replaceFirst()` changes the first '0' with an empty string.

You can use `replaceAllMapped()` to register a function that modifies the
matches:

--------------------------------------------------------------------------------
var heart = '\u2661'; // '‚ô°'
var string = 'I like Ike but I $heart Lucy';
var regExp = new RegExp(r'[A-Z]\w+');
string.replaceAllMapped(regExp, (match) {
  return match.group(0).toUpperCase()
}); // 'I like IKE but I ‚ô° LUCY'
--------------------------------------------------------------------------------

The regular expression in the example above matches all words that begin with
a capital letter. The function passed to `replaceAllMapped()` returns a new
string with the matched strings converted to uppercase.

